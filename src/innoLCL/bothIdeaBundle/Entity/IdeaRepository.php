<?php

namespace innoLCL\bothIdeaBundle\Entity;

/**
 * IdeaRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class IdeaRepository extends \Doctrine\ORM\EntityRepository
{
    /**
    * Donne le nombre d'idée ayant ce statut, et son etats de validation
    *
    * @param string $statut, bool $confirmated
    * @return int
    */
    public function getIdeaCountByStatut($statut,$validated = 0,$not = false) 
    {
        $qb = $this->createQueryBuilder('a');
        $qb
            ->select('COUNT(a)')
            ->where('a.validated = :validated')
                            ->setParameter('validated', $validated);
        if($not === true) 
        {
            $qb->andwhere('a.statuts != :statut')
                  ->setParameter('statut', $statut);
        }
        else
        {
            $qb->andwhere('a.statuts = :statut')
                  ->setParameter('statut', $statut);
        }
        return $qb->getQuery()->getSingleScalarResult();
    }
    
    /**
    * Donne le nombre d'idée selectionnée
    *
    * @param none
    * @return int
    */
    public function getSelectedIdeaCount() 
    {
        $qb = $this->createQueryBuilder('a');
        $qb
            ->select('COUNT(a)')
            ->where('a.selected = :selected')
            ->setParameter('selected', 1);
        return $qb->getQuery()->getSingleScalarResult();
    }
    
    /**
    * Donne le nombre d'idée selectionnée
    *
    * @param none
    * @return int
    */
    public function getSelectedIdeaBlockedCount() 
    {
        $qb = $this->createQueryBuilder('a');
        $qb
            ->select('COUNT(a)')
            ->where('a.selected = :selected')
            ->setParameter('selected', 2);
        return $qb->getQuery()->getSingleScalarResult();
    }
    
    
    /**
    * Dit si la derniere idée est validé
    *
    * @param int $idUser
    * @return bool
    */
    public function isUserLastIdeaValidated($idUser) 
    {
        $qb = $this->createQueryBuilder('a');
        $qb
            ->select('a')
            ->where('a.author = :author')
            ->setParameter('author', $idUser)
            ->orderBy('a.postedon', 'DESC')
            ->orderBy('a.id', 'DESC')
            ->setMaxResults(1);
        $lastIdea = $qb->getQuery()->getOneOrNullResult();
        if($lastIdea != null && $lastIdea->getValidated() == 1) 
        {
            return true;
        }
        else 
        {
            return false;
        }
    }
    
    /**
    * Dit si la derniere idée est refused
    *
    * @param int $idUser
    * @return bool
    */
    public function isUserLastIdeaRefused($idUser) 
    {
        $qb = $this->createQueryBuilder('a');
        $qb
            ->select('a')
            ->where('a.author = :author')
            ->setParameter('author', $idUser)
            ->orderBy('a.postedon', 'DESC')
            ->orderBy('a.id', 'DESC')
            ->setMaxResults(1);
        $lastIdea = $qb->getQuery()->getOneOrNullResult();
        if($lastIdea != null && $lastIdea->getStatuts() == "refused") 
        {
            return true;
        }
        else 
        {
            return false;
        }
    }
    
    /**
    * retourne l'idée de la dernière idée d'un utilisateur
    *
    * @param int $idUser
    * @return bool
    */
    public function getLastIdeaIdOfUser($idUser) 
    {
        $qb = $this->createQueryBuilder('a');
        $qb
            ->select('a')
            ->where('a.author = :author')
            ->setParameter('author', $idUser)
            ->orderBy('a.postedon', 'DESC')
            ->orderBy('a.id', 'DESC')
            ->setMaxResults(1);
        $lastIdea = $qb->getQuery()->getOneOrNullResult();
        if($lastIdea != null) 
        {
            return $lastIdea->getId();
        }
        else 
        {
            return 0;
        }
    }
    
    /**
    * retourne le nombre d'idée d'un user
    *
    * @param int $idUser
    * @return int
    */
    public function getCountIdeaOfUser($idUser) 
    {
        $qb = $this->createQueryBuilder('a');
        $qb
            ->select('COUNT(a)')
            ->where('a.author = :author')
            ->setParameter('author', $idUser)
            ->setMaxResults(1);
        return $qb->getQuery()->getSingleScalarResult();
    }
    
    /**
    * 
    *
    * @param int $idUser
    * @return int
    */
    public function getListIdeaByStatut($statut,$validated = 0,$not = false,$page = 1) 
    {
        $limit = 15;
		
        $first = ($page - 1) * $limit;
        $qb = $this->createQueryBuilder('a')
                            ->join('a.author', 'user')
                            ->where('a.validated = :validated')
                            ->setParameter('validated', $validated)
                            ->addSelect('user');                            
        if($not === true) 
        {
            $qb->andwhere('a.statuts != :statut')
                  ->setParameter('statut', $statut);
        }
        else
        {
            $qb->andwhere('a.statuts = :statut')
                ->setParameter('statut', $statut);
        }
        if($page != 0) {
            $qb->setFirstResult($first)
                ->setMaxResults($limit); 
        }
                            
        return $qb->getQuery()->getResult();
    }
    
    
    function findAllNotRefusedFor($idUser) 
    {
        $query = $this->createQueryBuilder('i')
                ->where('i.author = :author')
                ->setParameter('author', $idUser)
                ->andWhere('i.statuts != :statut')
                ->setParameter('statut', "refused");
        
        return $query->getQuery()->getResult();
    }
    
    /**
    * retourne la liste des idées non validés (validateur), dont la version n'est pas modéré ou dont la version est modéré dans sa version actuelle par un user précis et avec un statut précis
    */
    public function getModerateurListIdea($user = false, $ModerateurReviewStatus = false,$page = 1) {
		//base idea non validé.
		$qb = $this->createQueryBuilder('a')
					->join('a.author', 'user')
					->where('a.validated = 0');
		
		if($user != false) {
			//ajoute les reviews pour les tester
			$qb->leftjoin('a.reviews', 'review');
			
			if($ModerateurReviewStatus == false) {
				//Subquery : recupère les IDs des idées ayant une review actuelle par ce modérateur
				$subqb = $this->createQueryBuilder('i')
							  ->select('i.id')
							  ->join('i.reviews', 'review')
							  ->where('i.validated = 0')
							  ->andWhere('review.versionIdea = i.version')
							  ->andWhere('review.moderateur = :user')
							  ->setParameter('user', $user);
				$subresults = $subqb->getQuery()->getResult();	
				//$notArray = array_column($subresults, "id");
				$notArray = array_map(function($element){return $element['id'];}, $subresults);
				
				
				//Supprime les idées ayant une review actuelle par ce modérateur			
				if(count($notArray)) {
					$qb->andWhere($qb->expr()->notIn('a.id', $notArray));
				}
				// prends les idées sans reviews ou avec une review de ce modérateur mais sur une version antérieure
				$qb->andWhere('review.moderateur IS NULL OR review.moderateur != :user')
						->setParameter('user', $user);
			}
			else {
				//prends les idées avec une review de ce modérateur pour la version actuelle de l'idée et dont l'avis est de type Moderateur status
			$qb->andWhere('review.moderateur = :user AND review.versionIdea = a.version AND review.avis = :ModerateurReviewStatus')
						->setParameter('user', $user)
						->setParameter('ModerateurReviewStatus', $ModerateurReviewStatus);	
			}
		}
		
		//Gestion pagination
		$limit = 15;		
		$first = ($page - 1) * $limit;
		if($page != 0) {
        $qb->setFirstResult($first)
           ->setMaxResults($limit); 
        }
		
		return $qb->getQuery()->getResult();				
	}
    
    /**
    * Compte le nb idées non validés (validateur), dont la version n'est pas modéré ou dont la version est modéré dans sa version actuelle par un user précis et avec un statut précis
    */
    public function getModerateurListIdeaCount($user = false, $ModerateurReviewStatus = false) {
		//base idea non validé.
		$qb = $this->createQueryBuilder('a')
					->select('COUNT(a)')
					->join('a.author', 'user')
					->where('a.validated = 0');
		
		if($user != false) {
			//ajoute les reviews pour les tester
			$qb->leftjoin('a.reviews', 'review');			
			if($ModerateurReviewStatus == false) {
				//Subquery : recupère les IDs des idées ayant une review actuelle par ce modérateur
				$subqb = $this->createQueryBuilder('i')
							  ->select('i.id')
							  ->join('i.reviews', 'review')
							  ->where('i.validated = 0')
							  ->andWhere('review.versionIdea = i.version')
							  ->andWhere('review.moderateur = :user')
							  ->setParameter('user', $user);
				$subresults = $subqb->getQuery()->getResult();	
				$notArray = array_map(function($element){return $element['id'];}, $subresults);
				
				
				//Supprime les idées ayant une review actuelle par ce modérateur			
				if(count($notArray)) {
					$qb->andWhere($qb->expr()->notIn('a.id', $notArray));
				}
				// prends les idées sans reviews ou avec une review de ce modérateur mais sur une version antérieure
				$qb->andWhere('review.moderateur IS NULL OR review.moderateur != :user')
						->setParameter('user', $user);
			}
			else {
				//prends les idées avec une review de ce modérateur pour la version actuelle de l'idée et dont l'avis est de type Moderateur status
			$qb->andWhere('review.moderateur = :user AND review.versionIdea = a.version AND review.avis = :ModerateurReviewStatus')
						->setParameter('user', $user)
						->setParameter('ModerateurReviewStatus', $ModerateurReviewStatus);	
			}
		}
		return $qb->getQuery()->getSingleScalarResult();				
	}
	
	/**
    * retourne la liste des idées non validés (validateur), qui ont au moins un avis donné pour la version actuelle de l'idée
    */
    public function getLecteurValidateurListIdea($page = 1) {
		//base idea non validé.
		$qb = $this->createQueryBuilder('a')
					->join('a.author', 'user')
					->join('a.reviews', 'review')
					->select('a')
					->groupBy('a')
					->where('a.validated = 0');

				// prends les idées  avec une review modérateur sur cette version
				$qb->andWhere('review.versionIdea = a.version');
		
		//Gestion pagination
		$limit = 15;		
		$first = ($page - 1) * $limit;
		if($page != 0) {
        $qb->setFirstResult($first)
           ->setMaxResults($limit); 
        }
		
		return $qb->getQuery()->getResult();				
	}
	
	/**
    * Compte le nb d'idées non validés (validateur), qui ont au moins un avis donné pour la version actuelle de l'idée
    */
    public function getLecteurValidateurListIdeaCount() {
		//base idea non validé.
		$qb = $this->createQueryBuilder('a')
					->select('a.id')
					->join('a.author', 'user')
					->join('a.reviews', 'review')
					->groupBy('a.id')
					->where('a.validated = 0');

				// prends les idées  avec une review modérateur sur cette version
				$qb->andWhere('review.versionIdea = a.version');
		
		//le count a ce niveau et non dans le query sert a eviter les duplicats d'idée qui ne pourrait etre join avec un COUNT SQL (Si c'est possible, merci de me montrer la requete)
		return count($qb->getQuery()->getResult());				
	}
}
